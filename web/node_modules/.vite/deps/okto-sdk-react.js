import {
  axios_default
} from "./chunk-RNAYCFOQ.js";
import {
  require_react
} from "./chunk-QCHXOAYK.js";
import {
  __toESM
} from "./chunk-WOOG5QLI.js";

// node_modules/okto-sdk-react/dist/esm/index.js
var import_react = __toESM(require_react());
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
var BuildType;
(function(BuildType2) {
  BuildType2["STAGING"] = "STAGING";
  BuildType2["SANDBOX"] = "SANDBOX";
  BuildType2["PRODUCTION"] = "PRODUCTION";
})(BuildType || (BuildType = {}));
var ModalType;
(function(ModalType2) {
  ModalType2["WIDGET"] = "WIDGET";
})(ModalType || (ModalType = {}));
var OrderStatus;
(function(OrderStatus2) {
  OrderStatus2["SUCCESS"] = "SUCCESS";
  OrderStatus2["FAILED"] = "FAILED";
  OrderStatus2["PENDING"] = "PENDING";
})(OrderStatus || (OrderStatus = {}));
function getQueryString(query) {
  const queryParams = [];
  for (const [key, value] of Object.entries(query)) {
    if (value !== void 0) {
      queryParams.push(`${key}=${value}`);
    }
  }
  const queryString = queryParams.join("&");
  return queryString;
}
var baseUrls = {
  [BuildType.PRODUCTION]: "https://apigw.okto.tech",
  [BuildType.STAGING]: "https://3p-bff.oktostage.com",
  [BuildType.SANDBOX]: "https://sandbox-api.okto.tech"
};
var widgetUrl = "https://3p.okto.tech/";
var AUTH_DETAILS_KEY = "AUTH_DETAILS";
var defaultTheme = {
  textPrimaryColor: "0xFFFFFFFF",
  textSecondaryColor: "0xFFFFFFFF",
  textTertiaryColor: "0xFFFFFFFF",
  accent1Color: "0x80433454",
  accent2Color: "0x80905BF5",
  strokeBorderColor: "0xFFACACAB",
  strokeDividerColor: "0x4DA8A8A8",
  surfaceColor: "0xFF1F0A2F",
  backgroundColor: "0xFF000000"
};
var JOB_RETRY_INTERVAL = 5e3;
var JOB_MAX_RETRY = 12;
var storeJSONLocalStorage = (key, value) => __awaiter(void 0, void 0, void 0, function* () {
  try {
    localStorage.setItem(key, JSON.stringify(value));
  } catch (e) {
    console.error("Error storing JSON data in local storage", e);
  }
});
var getJSONLocalStorage = (key) => __awaiter(void 0, void 0, void 0, function* () {
  if (typeof window === "undefined") {
    return null;
  }
  try {
    const jsonValue = localStorage.getItem(key);
    if (jsonValue !== null && jsonValue !== "undefined") {
      const value = JSON.parse(jsonValue);
      return value;
    }
    return null;
  } catch (e) {
    console.error("Error getting JSON data from local storage", e);
  }
  return null;
});
function styleInject(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;
  if (!css || typeof document === "undefined") {
    return;
  }
  var head = document.head || document.getElementsByTagName("head")[0];
  var style = document.createElement("style");
  style.type = "text/css";
  if (insertAt === "top") {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}
var css_248z$2 = ".WidgetIframe-module_container__XpJd6{height:32rem;width:20rem}.WidgetIframe-module_iframe__pHk97{background-color:#000;border-radius:24px;height:100%;width:100%}.WidgetIframe-module_hidden__dpiV5{display:none}.WidgetIframe-module_block__VTCNM{display:block}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIldpZGdldElmcmFtZS5tb2R1bGUuY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLHNDQUVFLFlBQWEsQ0FEYixXQUVGLENBRUEsbUNBSUUscUJBQXVCLENBRHZCLGtCQUFtQixDQURuQixXQUFZLENBRFosVUFJRixDQUVBLG1DQUNFLFlBQ0YsQ0FFQSxrQ0FDRSxhQUNGIiwiZmlsZSI6IldpZGdldElmcmFtZS5tb2R1bGUuY3NzIiwic291cmNlc0NvbnRlbnQiOlsiLmNvbnRhaW5lciB7XG4gIHdpZHRoOiAyMHJlbTtcbiAgaGVpZ2h0OiAzMnJlbTtcbn1cblxuLmlmcmFtZSB7XG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IDEwMCU7XG4gIGJvcmRlci1yYWRpdXM6IDI0cHg7XG4gIGJhY2tncm91bmQtY29sb3I6IGJsYWNrO1xufVxuXG4uaGlkZGVuIHtcbiAgZGlzcGxheTogbm9uZTtcbn1cblxuLmJsb2NrIHtcbiAgZGlzcGxheTogYmxvY2s7XG59XG5cbiJdfQ== */";
var styles$2 = { "container": "WidgetIframe-module_container__XpJd6", "iframe": "WidgetIframe-module_iframe__pHk97", "hidden": "WidgetIframe-module_hidden__dpiV5", "block": "WidgetIframe-module_block__VTCNM" };
styleInject(css_248z$2);
var css_248z$1 = ".Loading-module_loading__ccSwl{align-items:center;display:flex;height:100%;justify-content:center;width:100%}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkxvYWRpbmcubW9kdWxlLmNzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSwrQkFFRSxrQkFBbUIsQ0FEbkIsWUFBYSxDQUliLFdBQVksQ0FGWixzQkFBdUIsQ0FDdkIsVUFFRiIsImZpbGUiOiJMb2FkaW5nLm1vZHVsZS5jc3MiLCJzb3VyY2VzQ29udGVudCI6WyIubG9hZGluZyB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICB3aWR0aDogMTAwJTtcbiAgaGVpZ2h0OiAxMDAlO1xufVxuXG4uc3Bpbm5lciB7XG4gIC8qIEFkZCB5b3VyIHNwaW5uZXIgc3R5bGVzIGhlcmUgKi9cbn1cbiJdfQ== */";
var styles$1 = { "loading": "Loading-module_loading__ccSwl", "spinner": "Loading-module_spinner__TOVv5" };
styleInject(css_248z$1);
function Loading() {
  return import_react.default.createElement(
    "div",
    { className: styles$1.loading },
    import_react.default.createElement("div", { className: styles$1.spinner }, "Loading...")
  );
}
function getInjectedData(modalData) {
  return {
    textPrimaryColor: modalData.theme.textPrimaryColor,
    textSecondaryColor: modalData.theme.textSecondaryColor,
    textTertiaryColor: modalData.theme.textTertiaryColor,
    accent1Color: modalData.theme.accent1Color,
    accent2Color: modalData.theme.accent2Color,
    strokeBorderColor: modalData.theme.strokeBorderColor,
    strokeDividerColor: modalData.theme.strokeDividerColor,
    surfaceColor: modalData.theme.surfaceColor,
    backgroundColor: modalData.theme.backgroundColor,
    ENVIRONMENT: modalData.environment,
    authToken: modalData.authToken
  };
}
var WidgetIframe = ({ modalData, onClose }) => {
  const iframeRef = (0, import_react.useRef)(null);
  const [loading, setLoading] = (0, import_react.useState)(true);
  (0, import_react.useEffect)(() => {
    const iframe = iframeRef.current;
    if (!iframe) {
      return;
    }
    iframe.onload = function() {
      onLoad();
    };
    function onLoad() {
      console.log(modalData);
      if (iframe && iframe.contentWindow && modalData) {
        const message = {
          type: "FROM_PARENT",
          data: getInjectedData(modalData)
        };
        iframe.contentWindow.postMessage(message, widgetUrl);
      }
      setLoading(false);
    }
  }, []);
  (0, import_react.useEffect)(() => {
    const handleMessage = (event) => {
      if (event.origin === widgetUrl) {
        const message = event.data;
        if (message.type === "FROM_IFRAME") {
          if (message.data === "CLOSE") {
            onClose();
          }
        }
      }
    };
    window.addEventListener("message", handleMessage);
    return () => {
      window.removeEventListener("message", handleMessage);
    };
  }, []);
  return import_react.default.createElement(
    "div",
    { className: styles$2.container },
    loading && import_react.default.createElement(Loading, null),
    import_react.default.createElement("iframe", { ref: iframeRef, src: widgetUrl, className: styles$2.iframe, loading: "lazy" })
  );
};
var css_248z = ".OktoModal-module_modalOverlay__7Bxvs{align-items:center;display:flex;inset:0;justify-content:center;position:fixed;z-index:50}.OktoModal-module_hidden__DFJwo{display:none}.OktoModal-module_modalContainer__8GLNJ{align-items:center;display:flex;inset:0;justify-content:center;position:fixed}.OktoModal-module_modalContent__KLXfE{border:2px solid #f5f6fe;border-radius:24px;box-shadow:0 10px 15px -3px rgba(0,0,0,.1),0 4px 6px -2px rgba(0,0,0,.05)}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIk9rdG9Nb2RhbC5tb2R1bGUuY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLHNDQU1FLGtCQUFtQixDQUZuQixZQUFhLENBRmIsT0FBUSxDQUdSLHNCQUF1QixDQUp2QixjQUFlLENBRWYsVUFJRixDQUVBLGdDQUNFLFlBQ0YsQ0FFQSx3Q0FLRSxrQkFBbUIsQ0FGbkIsWUFBYSxDQURiLE9BQVEsQ0FFUixzQkFBdUIsQ0FIdkIsY0FLRixDQUVBLHNDQUNFLHdCQUF5QixDQUN6QixrQkFBbUIsQ0FDbkIseUVBQ0YiLCJmaWxlIjoiT2t0b01vZGFsLm1vZHVsZS5jc3MiLCJzb3VyY2VzQ29udGVudCI6WyIubW9kYWxPdmVybGF5IHtcbiAgcG9zaXRpb246IGZpeGVkO1xuICBpbnNldDogMDtcbiAgei1pbmRleDogNTA7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xufVxuXG4uaGlkZGVuIHtcbiAgZGlzcGxheTogbm9uZTtcbn1cblxuLm1vZGFsQ29udGFpbmVyIHtcbiAgcG9zaXRpb246IGZpeGVkO1xuICBpbnNldDogMDtcbiAgZGlzcGxheTogZmxleDtcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG59XG5cbi5tb2RhbENvbnRlbnQge1xuICBib3JkZXI6IDJweCBzb2xpZCAjRjVGNkZFO1xuICBib3JkZXItcmFkaXVzOiAyNHB4O1xuICBib3gtc2hhZG93OiAwcHggMTBweCAxNXB4IC0zcHggcmdiYSgwLCAwLCAwLCAwLjEpLCAwcHggNHB4IDZweCAtMnB4IHJnYmEoMCwgMCwgMCwgMC4wNSk7XG59XG4iXX0= */";
var styles = { "modalOverlay": "OktoModal-module_modalOverlay__7Bxvs", "hidden": "OktoModal-module_hidden__DFJwo", "modalContainer": "OktoModal-module_modalContainer__8GLNJ", "modalContent": "OktoModal-module_modalContent__KLXfE" };
styleInject(css_248z);
var _OktoModal = ({}, ref) => {
  const [currentScreen, setCurrentScreen] = (0, import_react.useState)(null);
  const [modalData, setModalData] = (0, import_react.useState)(null);
  const openModal = (screen, widgetModalData = null) => {
    setCurrentScreen(screen);
    if (widgetModalData) {
      setModalData(widgetModalData);
    }
  };
  const closeModal = () => {
    setCurrentScreen(null);
  };
  (0, import_react.useImperativeHandle)(ref, () => ({
    openModal,
    closeModal
  }));
  function handleClose() {
    closeModal();
  }
  return import_react.default.createElement(
    "div",
    { className: `${styles.modalOverlay} ${currentScreen ? "" : styles.hidden}`, onClick: handleClose },
    import_react.default.createElement(
      "div",
      { className: styles.modalContainer },
      import_react.default.createElement("div", { className: styles.modalContent }, currentScreen === ModalType.WIDGET && import_react.default.createElement(WidgetIframe, { modalData, onClose: handleClose }))
    )
  );
};
var OktoModal = (0, import_react.forwardRef)(_OktoModal);
var OktoContext = (0, import_react.createContext)(null);
var OktoProvider = ({ children, apiKey, buildType }) => {
  const oktoModalRef = (0, import_react.useRef)(null);
  const baseUrl = (0, import_react.useMemo)(() => baseUrls[buildType], [buildType]);
  const [authDetails, setAuthDetails] = (0, import_react.useState)(null);
  const [theme, updateTheme] = (0, import_react.useState)(defaultTheme);
  const isLoggedIn = (0, import_react.useMemo)(() => authDetails !== null, [authDetails]);
  const axiosInstance = (0, import_react.useMemo)(() => {
    const axiosInstanceTmp = axios_default.create({
      baseURL: `${baseUrl}/api`,
      headers: {
        "Content-Type": "application/json",
        "x-api-key": apiKey
      }
    });
    axiosInstanceTmp.interceptors.request.use((config) => {
      if (authDetails === null || authDetails === void 0 ? void 0 : authDetails.authToken) {
        config.headers.Authorization = `Bearer ${authDetails.authToken}`;
      }
      return config;
    }, (error) => {
      return Promise.reject(error);
    });
    axiosInstanceTmp.interceptors.response.use((response) => response, (error) => __awaiter(void 0, void 0, void 0, function* () {
      const originalRequest = error.config;
      if (error.response.status === 401) {
        try {
          const newAuthDetails = yield refreshToken();
          if (newAuthDetails) {
            originalRequest.headers.Authorization = `Bearer ${newAuthDetails.authToken}`;
            return axios_default(originalRequest);
          }
        } catch (refreshError) {
          updateAuthDetails(null);
          return Promise.reject(refreshError);
        }
      }
      return Promise.reject(error);
    }));
    return axiosInstanceTmp;
  }, [apiKey, authDetails, baseUrl]);
  (0, import_react.useEffect)(() => {
    updateAuthDetailsFromStorage();
  }, []);
  function updateAuthDetailsFromStorage() {
    return __awaiter(this, void 0, void 0, function* () {
      const storedAuthDetails = yield getJSONLocalStorage(AUTH_DETAILS_KEY);
      setAuthDetails(storedAuthDetails);
    });
  }
  function updateAuthDetails(authDetailsNew) {
    return __awaiter(this, void 0, void 0, function* () {
      setAuthDetails(authDetailsNew);
      yield storeJSONLocalStorage(AUTH_DETAILS_KEY, authDetailsNew);
    });
  }
  function refreshToken() {
    return __awaiter(this, void 0, void 0, function* () {
      if (authDetails) {
        try {
          const response = yield axios_default.post(`${baseUrl}/api/v1/refresh_token`, {}, {
            headers: {
              Accept: "application/json",
              Authorization: `Bearer ${authDetails === null || authDetails === void 0 ? void 0 : authDetails.authToken}`,
              "x-refresh-authorization": `Bearer ${authDetails.refreshToken}`,
              "x-device-token": authDetails.deviceToken,
              "x-api-key": apiKey
            }
          });
          const authDetailsNew = {
            authToken: response.data.data.auth_token,
            refreshToken: response.data.data.refresh_auth_token,
            deviceToken: response.data.data.device_token
          };
          updateAuthDetails(authDetailsNew);
          console.log("Refresh token: ", "success");
          return authDetailsNew;
        } catch (error) {
          throw new Error("Failed to refresh token");
        }
      }
      return null;
    });
  }
  function authenticate(idToken, callback) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!axiosInstance) {
        return callback(null, new Error("SDK is not initialized"));
      }
      try {
        const response = yield axios_default.post(`${baseUrl}/api/v2/authenticate`, {
          id_token: idToken
        }, {
          headers: {
            Accept: "*/*",
            "x-api-key": apiKey,
            "Content-Type": "application/json"
          }
        });
        if (response.status === 200 && response.data && response.data.status === "success") {
          if (response.data.data.auth_token) {
            const authDetailsNew = {
              authToken: response.data.data.auth_token,
              refreshToken: response.data.data.refresh_auth_token,
              deviceToken: response.data.data.device_token
            };
            updateAuthDetails(authDetailsNew);
          }
          callback(response.data.data, null);
        } else {
          callback(null, new Error("Server responded with an error"));
        }
      } catch (error) {
        callback(null, error);
      }
    });
  }
  function authenticateWithUserId(userId, jwtToken, callback) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!axiosInstance) {
        return callback(null, new Error("SDK is not initialized"));
      }
      try {
        const response = yield axios_default.post(`${baseUrl}/api/v1/jwt-authenticate`, {
          user_id: userId,
          auth_token: jwtToken
        }, {
          headers: {
            Accept: "*/*",
            "x-api-key": apiKey,
            "Content-Type": "application/json"
          }
        });
        if (response.status === 200 && response.data && response.data.status === "success") {
          const authDetailsNew = {
            authToken: response.data.data.auth_token,
            refreshToken: response.data.data.refresh_auth_token,
            deviceToken: response.data.data.device_token
          };
          updateAuthDetails(authDetailsNew);
          callback(response.data.data, null);
        } else {
          callback(null, new Error("Server responded with an error"));
        }
      } catch (error) {
        callback(null, error);
      }
    });
  }
  function makeGetRequest(endpoint_1) {
    return __awaiter(this, arguments, void 0, function* (endpoint, queryUrl = null) {
      if (!axiosInstance) {
        throw new Error("SDK is not initialized");
      }
      const url = queryUrl ? `${endpoint}?${queryUrl}` : endpoint;
      try {
        const response = yield axiosInstance.get(url);
        if (response.data.status === "success") {
          return response.data.data;
        } else {
          throw new Error("Server responded with an error");
        }
      } catch (error) {
        throw error instanceof Error ? error : new Error("Unknown error");
      }
    });
  }
  function makePostRequest(endpoint_1) {
    return __awaiter(this, arguments, void 0, function* (endpoint, data = null) {
      if (!axiosInstance) {
        throw new Error("SDK is not initialized");
      }
      try {
        const response = yield axiosInstance.post(endpoint, data);
        if (response.data.status === "success") {
          return response.data.data;
        } else {
          throw new Error("Server responded with an error");
        }
      } catch (error) {
        throw error instanceof Error ? error : new Error("Unknown error");
      }
    });
  }
  function getPortfolio() {
    return __awaiter(this, void 0, void 0, function* () {
      return makeGetRequest("/v1/portfolio");
    });
  }
  function getSupportedTokens() {
    return __awaiter(this, void 0, void 0, function* () {
      return makeGetRequest("/v1/supported/tokens");
    });
  }
  function getSupportedNetworks() {
    return __awaiter(this, void 0, void 0, function* () {
      return makeGetRequest("/v1/supported/networks");
    });
  }
  function getUserDetails() {
    return __awaiter(this, void 0, void 0, function* () {
      return makeGetRequest("/v1/user_from_token");
    });
  }
  function getWallets() {
    return __awaiter(this, void 0, void 0, function* () {
      return makeGetRequest("/v1/wallet");
    });
  }
  function orderHistory(query) {
    return __awaiter(this, void 0, void 0, function* () {
      const queryString = getQueryString(query);
      return makeGetRequest("/v1/orders", queryString);
    });
  }
  function getNftOrderDetails(query) {
    return __awaiter(this, void 0, void 0, function* () {
      const queryString = getQueryString(query);
      return makeGetRequest("/v1/nft/order_details", queryString);
    });
  }
  function getRawTransactionStatus(query) {
    return __awaiter(this, void 0, void 0, function* () {
      const queryString = getQueryString(query);
      return makeGetRequest("/v1/rawtransaction/status", queryString);
    });
  }
  function createWallet() {
    return __awaiter(this, void 0, void 0, function* () {
      return makePostRequest("/v1/wallet");
    });
  }
  function transferTokens(data) {
    return __awaiter(this, void 0, void 0, function* () {
      return makePostRequest("/v1/transfer/tokens/execute", data);
    });
  }
  function transferTokensWithJobStatus(data) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const { orderId } = yield transferTokens(data);
        console.log("Transfer tokens order ID", orderId);
        return yield waitForJobCompletion(orderId, (_orderId) => __awaiter(this, void 0, void 0, function* () {
          const orderData = yield orderHistory({ order_id: _orderId });
          const order = orderData.jobs.find((item) => item.order_id === _orderId);
          if (order && (order.status === OrderStatus.SUCCESS || order.status === OrderStatus.FAILED)) {
            return order;
          }
          throw new Error(`Order with ID ${_orderId} not found or not completed.`);
        }));
      } catch (error) {
        throw error instanceof Error ? error : new Error("Unknown error");
      }
    });
  }
  function transferNft(data) {
    return __awaiter(this, void 0, void 0, function* () {
      return makePostRequest("/v1/nft/transfer", data);
    });
  }
  function transferNftWithJobStatus(data) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const { order_id } = yield transferNft(data);
        console.log("Transfer nfts order ID", order_id);
        return yield waitForJobCompletion(order_id, (orderId) => __awaiter(this, void 0, void 0, function* () {
          const orderData = yield getNftOrderDetails({
            order_id: orderId
          });
          const order = orderData.nfts.find((item) => item.id === orderId);
          if (order) {
            return order;
          }
          throw new Error(`Order with ID ${orderId} not found or not completed.`);
        }));
      } catch (error) {
        throw error instanceof Error ? error : new Error("Unknown error");
      }
    });
  }
  function executeRawTransaction(data) {
    return __awaiter(this, void 0, void 0, function* () {
      return makePostRequest("/v1/rawtransaction/execute", data);
    });
  }
  function executeRawTransactionWithJobStatus(data) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const { jobId } = yield executeRawTransaction(data);
        console.log("Execute Raw transaction called with Job ID", jobId);
        return yield waitForJobCompletion(jobId, (orderId) => __awaiter(this, void 0, void 0, function* () {
          const orderData = yield getRawTransactionStatus({
            order_id: orderId
          });
          const order = orderData.jobs.find((item) => item.order_id === orderId);
          if (order && (order.status === OrderStatus.SUCCESS || order.status === OrderStatus.FAILED)) {
            return order;
          }
          throw new Error(`Order with ID ${orderId} not found or not completed.`);
        }));
      } catch (error) {
        throw error instanceof Error ? error : new Error("Unknown error");
      }
    });
  }
  function waitForJobCompletion(orderId, findJobCallback) {
    return __awaiter(this, void 0, void 0, function* () {
      for (let retryCount = 0; retryCount < JOB_MAX_RETRY; retryCount++) {
        try {
          return yield findJobCallback(orderId);
        } catch (error) {
        }
        yield delay(JOB_RETRY_INTERVAL);
      }
      throw new Error(`Order ID not found or not completed.`);
    });
  }
  function delay(ms) {
    return __awaiter(this, void 0, void 0, function* () {
      return new Promise((resolve) => setTimeout(resolve, ms));
    });
  }
  function logOut() {
    return __awaiter(this, void 0, void 0, function* () {
      updateAuthDetails(null);
    });
  }
  function showWidgetModal() {
    var _a;
    (_a = oktoModalRef.current) === null || _a === void 0 ? void 0 : _a.openModal(ModalType.WIDGET, {
      theme,
      authToken: authDetails === null || authDetails === void 0 ? void 0 : authDetails.authToken,
      environment: buildType.toString()
    });
  }
  function closeModal() {
    var _a;
    (_a = oktoModalRef.current) === null || _a === void 0 ? void 0 : _a.closeModal();
  }
  function setTheme(newTheme) {
    updateTheme(Object.assign(Object.assign({}, theme), newTheme));
  }
  function getTheme() {
    return theme;
  }
  return import_react.default.createElement(
    OktoContext.Provider,
    { value: {
      isLoggedIn,
      authenticate,
      authenticateWithUserId,
      logOut,
      getPortfolio,
      getSupportedNetworks,
      getSupportedTokens,
      getUserDetails,
      getWallets,
      orderHistory,
      getNftOrderDetails,
      getRawTransactionStatus,
      createWallet,
      transferNft,
      transferNftWithJobStatus,
      transferTokens,
      transferTokensWithJobStatus,
      executeRawTransaction,
      executeRawTransactionWithJobStatus,
      showWidgetModal,
      closeModal,
      setTheme,
      getTheme
    } },
    children,
    import_react.default.createElement(OktoModal, { ref: oktoModalRef })
  );
};
var useOkto = () => (0, import_react.useContext)(OktoContext);
export {
  BuildType,
  ModalType,
  OktoProvider,
  OrderStatus,
  useOkto
};
//# sourceMappingURL=okto-sdk-react.js.map
